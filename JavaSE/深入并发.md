## 深入并发

### 1. Java线程总述

- 基本概念

  - 线程：线程是依附于进程的，进程是分配资源的最小单位，一个进程可以生成多个线程，这些线程拥有共享的进程资源。就每个线程而言，只有很少的独有资源，如：控制线程运行的线程控制块，保留局部变量和少数参数的栈空间等。
  - 锁：锁不是一个对象、不是一个具体的东西，而是一种机制的名称。锁机制需要保证如下两种特性：
    - 互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程中的协调机制，这样在同一时间只有一个线程对需同步的代码块(复合操作)进行访问。互斥性我们也往往称为操作的原子性。
    - 可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致。
  - 挂起(Suspend)：当线程被挂起的时候，其会失去CPU的使用时间，直到被其他线程（用户线程或调度线程）唤醒。
  - 休眠(Sleep)：同样是会失去CPU的使用时间，但是在过了指定的休眠时间之后，它会自动激活，无需唤醒（整个唤醒表面看是自动的，但实际上也得有守护线程去唤醒，只是不需编程者手动干预）。
  - 阻塞(Block)：在线程执行时，所需要的资源不能得到，则线程被挂起，直到满足可操作的条件。
  - 非阻塞：在线程执行时，所需要的资源不能得到，则线程不是被挂起等待，而是继续执行其余事情，待条件满足了之后，收到了通知（同样是守护线程去做）再执行。

- 挂起和休眠

  - 挂起和休眠是独立的操作系统的概念，而阻塞与非阻塞则是在资源不能得到时的两种处理方式，不限于操作系统，当资源申请不到时，要么挂起线程等待、要么继续执行其他操作，资源被满足后再通知该线程重新请求。显然非阻塞的效率要高于阻塞，相应的实现的复杂度也要高一些。

  - 以前的jdk版本中，可以通过显示调用Thread的suspend方法实现挂起，通过resume方法唤醒挂起的线程，但是现在这两个方法已经被废弃，因为它们容易产生死锁。比如：当suspend的线程持有某个对象锁，而resume它的线程又正好需要使用此锁的时候，死锁就产生了。
  - 现在的JDK版本中，挂起是JVM的系统行为，程序员无需干涉。休眠的过程中也不会释放锁，但它一定会在某个时间后被唤醒，所以不会死锁。现在我们所说的挂起，往往并非指编写者的程序里主动挂起，而是由操作系统的线程调度器去控制。

- 等待队列(等待池)和同步队列(锁池)

  - 等待队列（等待池）：假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁（因为wait()方法必须出现在synchronized中，这样自然在执行wait()方法之前线程A就已经拥有了该对象的锁），同时线程A就进入到了该对象的等待队列（等待池）中，此时线程A状态为Waiting。如果另外的一个线程调用了相同对象的notifyAll()方法，那么处于该对象的等待池中的线程就会全部进入该对象的同步队列（锁池）中，准备争夺锁的拥有权。如果另外的一个线程调用了相同对象的notify()方法，那么仅仅有一个处于该对象的等待池中的线程（随机）会进入该对象的同步队列（锁池）。
  - 同步队列（锁池）：假设线程A已经拥有了某个对象（注意:不是类）的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的同步队列（锁池）中，这些线程状态为Blocked。

### 2. Java线程生命周期

- 在线程的生命周期中，它要经过**新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和死亡（Dead）5种状态**。尤其是当线程启动以后，它不可能一直"霸占"着CPU独自运行，所以CPU需要在多条线程之间切换，于是 **线程状态也会多次在运行、阻塞、就绪之间切换**。![线程生命周期](https://github.com/Ryokai96/java-note/blob/master/JavaSE/picture/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png?raw=true)

- 新建状态(New)

  当程序使用new关键字创建了一个线程之后，该线程就处于 新建状态，此时的线程情况如下：

  > 1. 此时JVM为其分配内存，并初始化其成员变量的值；
  > 2. 此时线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体；

- 就绪状态(Runnable)

  当线程对象调用了start()方法之后，该线程处于 **就绪状态**。此时的线程情况如下：

  > 1. 此时JVM会为其创建方法调用栈和程序计数器；
  >
  > 2. 该状态的线程一直处于线程就绪队列（尽管是采用队列形式，事实上，把它称为可运行池而不是可运行队列。因为CPU的调度不一定是按照先进先出的顺序来调度的），线程并没有开始运行；
  >
  > 3. 此时线程等待系统为其分配CPU时间片，并不是说执行了start()方法就立即执行；

- 运行状态(Running)

  当CPU开始调度处于就绪状态的线程时，此时线程获得了CPU时间片才得以真正开始执行run()方法的线程执行体，则该线程处于运行状态。

  > 1. 如果计算机只有一个CPU，那么在任何时刻只有一个线程处于运行状态；
  > 2. 如果在一个多处理器的机器上，将会有多个线程并行执行，处于运行状态；
  > 3. 当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的现象；

  处于运行状态的线程最为复杂，它不可能一直处于运行状态（除非它的线程执行体足够短，瞬间就执行结束了），线程在运行过程中需要被中断，目的是使其他线程获得执行的机会，线程调度的细节取决于底层平台所采用的策略。线程状态可能会变为阻塞状态、就绪状态和死亡状态。比如：

  > 1. 对于采用抢占式策略的系统而言，系统会给每个可执行的线程分配一个时间片来处理任务；当该时间片用完后，系统就会剥夺该线程所占用的资源，让其他线程获得执行的机会。线程就会又从运行状态变为就绪状态，重新等待系统分配资源；
  >
  > 2. 对于采用协作式策略的系统而言，只有当一个线程调用了它的yield()方法后才会放弃所占用的资源—也就是必须由该线程主动放弃所占用的资源，线程就会又从运行状态变为就绪状态。

  **另外要注意的是，无论调用start()方法或者直接调用run()方法，线程无法再返回新建状态，再次调用start()方法会抛出IllegaIThreadStateExccption异常。**

- 阻塞状态(Blocked)

  处于运行状态的线程在某些情况下，让出CPU并暂时停止自己的运行，进入 阻塞状态。当发生如下情况时，线程将会进入阻塞状态：

  > 1. 线程调用sleep()方法，主动放弃所占用的处理器资源，暂时进入中断状态（不会释放持有的对象锁），时间到后等待系统分配CPU继续执行；
  >
  > 2. 线程调用一个阻塞式IO方法，在该方法返回之前，该线程被阻塞；
  >
  > 3. 线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有;
  >
  > 4. 程序调用了线程的suspend方法将线程挂起；
  >
  > 5. 线程调用wait，等待notify/notifyAll唤醒时(会释放持有的对象锁)；

  阻塞状态分类：

  > 1. 等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；
  >
  > 2. 同步阻塞：线程在获取synchronized同步锁失败（因为锁被其它线程占用），它会进入到同步阻塞状态；
  >
  > 3. 其他阻塞：通过调用线程的sleep()或join()或发出I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态；

  在阻塞状态的线程只能进入就绪状态，无法直接进入运行状态。而就绪和运行状态之间的转换通常不受程序控制，而是由系统线程调度所决定。当处于就绪状态的线程获得处理器资源时，该线程进入运行状态；当处于运行状态的线程失去处理器资源时，该线程进入就绪状态。

  > 但有一个方法例外，调用yield()方法可以让运行状态的线程转入就绪状态。

- 等待状态(Waiting)

  线程处于无限制等待状态，等待一个特殊的事件来重新唤醒，如：

  > 1. 通过wait()方法进行等待的线程等待一个notify()或者notifyAll()方法；
  > 2. 通过join()方法进行等待的线程等待目标线程运行结束而唤醒；

  以上两种一旦通过相关事件唤醒线程，线程就进入了就绪（RUNNABLE）状态继续运行。

- 时限等待状态(Timed_waiting)

  线程进入了一个时限等待状态，如：

  > **sleep(3000)**，等待3秒后线程重新进行就绪（RUNNABLE）状态继续运行。

- 死亡状态(Dead)

  线程会以如下3种方式结束，结束后就处于死亡状态：

  > 1. run()或call()方法执行完成，线程正常结束；
  > 2. 线程抛出一个未捕获的Exception或Error；
  > 3. 直接调用该线程stop()方法来结束该线程—该方法容易导致死锁，通常不推荐使用；

  **线程一旦终止，不能回到新建或者就绪状态，若对一个终止的线程调用start()方法，会抛出IllegaIThreadStateExccption异常。**

### 3. 线程相关方法

- start & run

  > 1. start：线程启动方法，由新建状态变为就绪状态
  > 2. run：线程的执行体

- sleep & yield

  > 1. sleep：使线程进入阻塞状态一段时间，在该方法指定的时间内线程无法被唤醒，同时也不会释放对象锁，睡眠时间到了之后，进入就绪状态。
  > 2. yield：调用该方法的线程主动让出cpu资源，进入就绪状态，可能出现这样的情况：当某个线程调用yield方法之后，线程调度器又将其调度出来重新进入到运行状态执行。

- wait & notify/notifyAll

  wait & notify/notifyAll这三个都是Object类的方法。使用wait，notify和notifyAll前提是先获得调用对象的锁。

  > 1. 调用wait方法后，释放持有的对象锁，线程状态由Running变为Waiting，并将当前线程放置到对象的等待队列；
  >
  > 2. 调用notify或者notifyAll方法后，等待线程依旧不会从 wait 返回，需要调用 noitfy 的线程释放锁之后，等待线程才有机会从 wait 返回；
  >
  > 3. notify方法：将等待队列的一个等待线程从等待队列种移到同步队列中 ，而 notifyAll 方法：将等待队列种所有的线程全部移到同步队列，被移动的线程状态由 Waiting 变为 Blocked；
  > 4. 如果是通过notify来唤起的线程，那先进入wait的线程会先被唤起来；
  > 5. 如果是通过nootifyAll唤起的线程，默认情况是最后进入的会先被唤起来，即LIFO的策略；

- join

  join方法可以把指定线程合并到当前线程。线程的合并的含义就是将几个并行线程的线程合并为一个单线程执行，应用场景是当一个线程必须等待另一个线程执行完毕才能继续执行时。

- suspend & resume(已过时)

  suspend-线程进入阻塞状态，但不会释放锁。

  resume-使线程重新进入可执行状态。

  这两个方法已经被废弃，因为suspend的线程不会释放锁，如果resume它的线程需要获得该锁，会造成死锁的问题。

  > 如果需要手动阻塞一个线程，可以给线程对象设置一个标志变量，在这个线程 的run方法的无锁部分检测这个变量，若该变量被设置为需要挂起，则线程保持等待状态直到该变量被设置为能继续运行。

- stop(已过时)

  stop用于强制终止一个线程，是不安全的方法，已被废弃。

  stop一个线程会导致其释放所有已获得的锁（监视器以在栈顶产生ThreadDeath异常的方式被解锁），如果之前被这些监视器保护的任何对象处于不一致状态，其它线程看到的这些对象就会处于不一致状态。这种对象被称为受损的 （damaged）。比如：a向b转账500元，a的账户减少500元，然后b的账户增加500元，这个过程应该是原子性的，一般置于synchronized修饰的方法或代码块中，某个线程在a账户减少500元后被stop，b的账户并没有增加500元，其获得的锁也被释放，其他线程可以继续执行转账操作，可能造成大量的数据不一致。

  > 正确终止一个线程的方法一般有两种：
  >
  > 1. 使用退出标志，让run方法提前完成，使线程终止
  > 2. 使用interrupt方法中断线程，不过interrupt方法的使用效果并不像for+break语句那样，马上就停止循环，调用interrupt方法是在当前线程中打了一个停止标志，并不是真的停止线程。